<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Screw Label Maker â€” James's Workshop</title>
<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0c10; --surface: #12151c; --surface2: #181c26; --surface3: #1e2330;
  --border: #262d3f; --border-hover: #3a4460;
  --text: #e8ecf6; --text-dim: #8892ab; --text-muted: #555e75;
  --accent: #4d8bff; --accent-dim: rgba(77,139,255,0.12); --accent-border: rgba(77,139,255,0.25);
  --green: #34d399; --green-dim: rgba(52,211,153,0.12);
  --red: #f87171; --orange: #fb923c; --yellow: #fbbf24;
  --m2: #FF4444; --m25: #FF8C00; --m3: #FFD700; --m4: #22BB22; --m5: #3399FF; --m6: #9933FF;
  --radius: 10px;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family:'Outfit',sans-serif; background:var(--bg); color:var(--text); min-height:100vh; }

/* LAYOUT */
.app { display:grid; grid-template-columns:320px 1fr; min-height:100vh; }
.sidebar { background:var(--surface); border-right:1px solid var(--border); padding:1.2rem;
  overflow-y:auto; max-height:100vh; position:sticky; top:0; }
.main { padding:1.5rem; overflow-y:auto; }

/* SIDEBAR */
.logo { display:flex; align-items:center; gap:0.5rem; margin-bottom:1.2rem; padding-bottom:1rem;
  border-bottom:1px solid var(--border); }
.logo h1 { font-size:1.1rem; font-weight:800; letter-spacing:-0.03em; }
.logo h1 span { color:var(--accent); }
.logo-icon { font-size:1.4rem; }

.filter-group { margin-bottom:1rem; }
.filter-group label { display:block; font-size:0.68rem; text-transform:uppercase;
  letter-spacing:0.08em; color:var(--text-muted); font-weight:600; margin-bottom:0.4rem; }

.chip-group { display:flex; flex-wrap:wrap; gap:0.3rem; }
.chip { padding:0.3rem 0.6rem; border-radius:6px; font-size:0.75rem; font-weight:500;
  background:var(--surface2); border:1px solid var(--border); cursor:pointer; transition:all 0.15s;
  user-select:none; font-family:'JetBrains Mono',monospace; }
.chip:hover { border-color:var(--border-hover); background:var(--surface3); }
.chip.active { background:var(--accent-dim); border-color:var(--accent-border); color:var(--accent); }
.chip.size-chip.active { font-weight:700; }

.length-grid { display:grid; grid-template-columns:repeat(4, 1fr); gap:0.25rem; }
.length-chip { text-align:center; padding:0.25rem 0.2rem; font-size:0.72rem; }

/* ACTIONS */
.actions { display:flex; flex-direction:column; gap:0.4rem; margin-top:1rem;
  padding-top:1rem; border-top:1px solid var(--border); }
.btn { padding:0.6rem 1rem; border:none; border-radius:var(--radius); font-family:inherit;
  font-size:0.8rem; font-weight:600; cursor:pointer; transition:all 0.15s; text-align:center; }
.btn-primary { background:var(--accent); color:white; }
.btn-primary:hover { filter:brightness(1.1); transform:translateY(-1px); }
.btn-primary:disabled { opacity:0.4; cursor:not-allowed; transform:none; }
.btn-secondary { background:var(--surface2); color:var(--text-dim); border:1px solid var(--border); }
.btn-secondary:hover { border-color:var(--border-hover); color:var(--text); }
.btn-danger { background:rgba(248,113,113,0.1); color:var(--red); border:1px solid rgba(248,113,113,0.2); }
.btn-sm { padding:0.35rem 0.6rem; font-size:0.72rem; }

.select-count { text-align:center; padding:0.5rem; background:var(--surface2);
  border-radius:var(--radius); font-family:'JetBrains Mono',monospace;
  font-size:0.8rem; color:var(--text-dim); margin-bottom:0.4rem; }
.select-count strong { color:var(--accent); font-size:1.1rem; }

/* MAIN AREA */
.toolbar { display:flex; align-items:center; justify-content:space-between;
  margin-bottom:1rem; flex-wrap:wrap; gap:0.5rem; }
.toolbar h2 { font-size:1rem; font-weight:700; }
.toolbar-actions { display:flex; gap:0.4rem; align-items:center; }
.search-box { padding:0.4rem 0.7rem; background:var(--surface); border:1px solid var(--border);
  border-radius:var(--radius); color:var(--text); font-family:inherit; font-size:0.78rem;
  width:200px; outline:none; }
.search-box:focus { border-color:var(--accent-border); }

/* LABEL GRID */
.label-grid { display:grid; grid-template-columns:repeat(auto-fill, minmax(240px, 1fr));
  gap:0.5rem; margin-bottom:1.5rem; }
.label-card { background:var(--surface); border:1px solid var(--border); border-radius:var(--radius);
  padding:0.6rem; cursor:pointer; transition:all 0.15s; position:relative; }
.label-card:hover { border-color:var(--border-hover); transform:translateY(-1px); }
.label-card.selected { border-color:var(--accent-border); background:var(--accent-dim); }
.label-card.selected::after { content:'âœ“'; position:absolute; top:0.4rem; right:0.5rem;
  color:var(--accent); font-weight:700; font-size:0.9rem; }
.label-card canvas { width:100%; height:auto; border-radius:4px; background:white; }
.label-card .label-info { display:flex; justify-content:space-between; align-items:center;
  margin-top:0.3rem; font-size:0.65rem; color:var(--text-muted);
  font-family:'JetBrains Mono',monospace; }

/* PRINT PREVIEW MODAL */
.modal-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.7);
  z-index:100; align-items:center; justify-content:center; }
.modal-overlay.open { display:flex; }
.modal { background:var(--surface); border:1px solid var(--border); border-radius:16px;
  max-width:90vw; max-height:90vh; overflow:auto; padding:1.5rem; }
.modal h2 { font-size:1.1rem; font-weight:700; margin-bottom:1rem; }
.modal .sheet-preview { background:white; margin:0.5rem 0; }
.modal .modal-actions { display:flex; gap:0.5rem; margin-top:1rem; justify-content:flex-end; }

/* EMPTY STATE */
.empty-state { text-align:center; padding:4rem 2rem; color:var(--text-muted); }
.empty-state .empty-icon { font-size:3rem; margin-bottom:0.8rem; opacity:0.4; }
.empty-state p { font-size:0.85rem; line-height:1.6; }

/* Quick add row */
.quick-add { background:var(--surface2); border:1px solid var(--border); border-radius:var(--radius);
  padding:0.8rem 1rem; margin-bottom:1rem; }
.quick-add h3 { font-size:0.72rem; text-transform:uppercase; letter-spacing:0.08em;
  color:var(--text-muted); font-weight:600; margin-bottom:0.5rem; }
.quick-add-row { display:flex; gap:0.3rem; flex-wrap:wrap; align-items:center; }
.quick-select { padding:0.3rem 0.5rem; background:var(--surface); border:1px solid var(--border);
  border-radius:6px; color:var(--text); font-family:inherit; font-size:0.75rem; outline:none; }
.quick-select:focus { border-color:var(--accent-border); }
.qty-input { width:50px; padding:0.3rem; background:var(--surface); border:1px solid var(--border);
  border-radius:6px; color:var(--text); font-family:'JetBrains Mono',monospace;
  font-size:0.75rem; text-align:center; outline:none; }
.mode-btn.active { background:var(--accent-dim); color:var(--accent); border-color:var(--accent-border); }

@media (max-width:900px) {
  .app { grid-template-columns:1fr; }
  .sidebar { max-height:none; position:relative; border-right:none; border-bottom:1px solid var(--border); }
}
@media print {
  .sidebar, .toolbar, .quick-add, .modal-actions, .no-print { display:none !important; }
  .app { display:block; }
  .main { padding:0; }
  .label-grid { display:none; }
}
</style>
</head>
<body>
<div class="app">

<!-- â•â•â• SIDEBAR â•â•â• -->
<div class="sidebar">
  <div class="logo">
    <span class="logo-icon">âš™ï¸</span>
    <h1>Screw <span>Label Maker</span></h1>
  </div>

  <!-- Filters -->
  <div class="filter-group">
    <label>Category</label>
    <div class="chip-group" id="catFilter">
      <div class="chip active" data-val="screw" onclick="toggleFilter('cat','screw',this)">Screws</div>
      <div class="chip active" data-val="nut" onclick="toggleFilter('cat','nut',this)">Nuts</div>
      <div class="chip active" data-val="washer" onclick="toggleFilter('cat','washer',this)">Washers</div>
    </div>
  </div>

  <div class="filter-group">
    <label>Size</label>
    <div class="chip-group" id="sizeFilter">
      <div class="chip size-chip active" data-val="M2" onclick="toggleFilter('size','M2',this)" style="border-left:3px solid var(--m2)">M2</div>
      <div class="chip size-chip active" data-val="M2.5" onclick="toggleFilter('size','M2.5',this)" style="border-left:3px solid var(--m25)">M2.5</div>
      <div class="chip size-chip active" data-val="M3" onclick="toggleFilter('size','M3',this)" style="border-left:3px solid var(--m3)">M3</div>
      <div class="chip size-chip active" data-val="M4" onclick="toggleFilter('size','M4',this)" style="border-left:3px solid var(--m4)">M4</div>
      <div class="chip size-chip active" data-val="M5" onclick="toggleFilter('size','M5',this)" style="border-left:3px solid var(--m5)">M5</div>
      <div class="chip size-chip active" data-val="M6" onclick="toggleFilter('size','M6',this)" style="border-left:3px solid var(--m6)">M6</div>
    </div>
  </div>

  <div class="filter-group">
    <label>Head Type</label>
    <div class="chip-group" id="headFilter">
      <div class="chip active" data-val="CAP" onclick="toggleFilter('head','CAP',this)">CAP</div>
      <div class="chip active" data-val="BTN" onclick="toggleFilter('head','BTN',this)">BTN</div>
      <div class="chip active" data-val="CSK" onclick="toggleFilter('head','CSK',this)">CSK</div>
      <div class="chip active" data-val="RCSK" onclick="toggleFilter('head','RCSK',this)">RCSK</div>
    </div>
  </div>

  <div class="filter-group">
    <label>Drive</label>
    <div class="chip-group" id="driveFilter">
      <div class="chip active" data-val="PH" onclick="toggleFilter('drive','PH',this)">PH +</div>
      <div class="chip active" data-val="HX" onclick="toggleFilter('drive','HX',this)">HX â¬¡</div>
    </div>
  </div>

  <div class="filter-group">
    <label>Material</label>
    <div class="chip-group" id="matFilter">
      <div class="chip active" data-val="Black" onclick="toggleFilter('mat','Black',this)">Black</div>
      <div class="chip active" data-val="Stainless" onclick="toggleFilter('mat','Stainless',this)">Stainless</div>
    </div>
  </div>

  <div class="filter-group">
    <label>Length (mm)</label>
    <div class="chip-group length-grid" id="lenFilter"></div>
  </div>

  <!-- Selection info & actions -->
  <div class="actions">
    <div class="select-count">
      <strong id="selectedCount">0</strong> labels selected
    </div>
    <button class="btn btn-primary" id="btnGenSheet" onclick="generateSheet()" disabled>
      ğŸ–¨ï¸ Generate Print Sheet
    </button>
    <button class="btn btn-secondary" onclick="downloadSelected()">
      ğŸ’¾ Download Selected PNGs
    </button>
    <div style="display:flex;gap:0.3rem;">
      <button class="btn btn-secondary btn-sm" onclick="selectAllVisible()" style="flex:1">Select Visible</button>
      <button class="btn btn-danger btn-sm" onclick="clearSelection()" style="flex:1">Clear All</button>
    </div>
  </div>
</div>

<!-- â•â•â• MAIN â•â•â• -->
<div class="main">
  <div class="toolbar">
    <h2>Label Browser <span id="visibleCount" style="color:var(--text-muted);font-weight:400;font-size:0.8rem"></span></h2>
    <div class="toolbar-actions">
      <input type="text" class="search-box" placeholder="Search (e.g. M4 12 hex)..." oninput="applyFilters()" id="searchBox">
    </div>
  </div>

  <!-- Quick Add -->
  <div class="quick-add">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
      <h3 style="margin-bottom:0;">âš¡ Quick Add Label</h3>
      <div style="display:flex;gap:0.25rem;">
        <button class="btn btn-secondary btn-sm mode-btn active" data-mode="single" onclick="setQuickAddMode('single')">Single</button>
        <button class="btn btn-secondary btn-sm mode-btn" data-mode="dual" onclick="setQuickAddMode('dual')">Dual</button>
        <button class="btn btn-secondary btn-sm mode-btn" data-mode="triple" onclick="setQuickAddMode('triple')">Triple</button>
        <button class="btn btn-secondary btn-sm mode-btn" data-mode="quad" onclick="setQuickAddMode('quad')">Quad</button>
      </div>
    </div>
    <div class="quick-add-row" id="qaSingleRow">
      <select class="quick-select" id="qaSize"><option value="">Size</option></select>
      <input type="number" class="qty-input" id="qaLength" placeholder="mm" min="1" max="200" list="qaLengthSuggestions" style="width:70px">
      <datalist id="qaLengthSuggestions"></datalist>
      <select class="quick-select" id="qaHead"><option value="">Head</option></select>
      <select class="quick-select" id="qaDrive"><option value="">Drive</option></select>
      <select class="quick-select" id="qaMat"><option value="">Material</option></select>
      <label style="font-size:0.72rem;color:var(--text-muted);display:flex;align-items:center;gap:0.3rem;">
        Qty: <input type="number" class="qty-input" id="qaQty" value="1" min="1" max="20">
      </label>
      <button class="btn btn-primary btn-sm" onclick="quickAdd()">+ Add</button>
    </div>
    <div id="qaDualRows" style="display:none">
      <div class="quick-add-row" style="margin-bottom:0.3rem;">
        <span style="font-size:0.75rem;font-weight:700;color:var(--text-dim);min-width:18px;">L:</span>
        <select class="quick-select" id="qaLCat" onchange="updateDualCatVisibility('qaL')"><option value="screw">Screw</option><option value="nut">Nut</option><option value="washer">Washer</option></select>
        <select class="quick-select" id="qaLSize"><option value="">Size</option></select>
        <input type="number" class="qty-input" id="qaLLength" placeholder="mm" min="1" max="200" list="qaLLengthSuggestions" style="width:70px">
        <datalist id="qaLLengthSuggestions"></datalist>
        <select class="quick-select" id="qaLHead"><option value="">Head</option></select>
        <select class="quick-select" id="qaLDrive"><option value="">Drive</option></select>
        <select class="quick-select" id="qaLMat"><option value="">Material</option></select>
      </div>
      <div class="quick-add-row" style="margin-bottom:0.3rem;">
        <span style="font-size:0.75rem;font-weight:700;color:var(--text-dim);min-width:18px;">R:</span>
        <select class="quick-select" id="qaRCat" onchange="updateDualCatVisibility('qaR')"><option value="screw">Screw</option><option value="nut">Nut</option><option value="washer">Washer</option></select>
        <select class="quick-select" id="qaRSize"><option value="">Size</option></select>
        <input type="number" class="qty-input" id="qaRLength" placeholder="mm" min="1" max="200" list="qaRLengthSuggestions" style="width:70px">
        <datalist id="qaRLengthSuggestions"></datalist>
        <select class="quick-select" id="qaRHead"><option value="">Head</option></select>
        <select class="quick-select" id="qaRDrive"><option value="">Drive</option></select>
        <select class="quick-select" id="qaRMat"><option value="">Material</option></select>
      </div>
      <div class="quick-add-row" style="justify-content:flex-end;">
        <label style="font-size:0.72rem;color:var(--text-muted);display:flex;align-items:center;gap:0.3rem;">
          Qty: <input type="number" class="qty-input" id="qaDualQty" value="1" min="1" max="20">
        </label>
        <button class="btn btn-primary btn-sm" onclick="quickAdd()">+ Add</button>
      </div>
    </div>
    <div id="qaTripleRows" style="display:none">
      <div class="quick-add-row" style="margin-bottom:0.3rem;">
        <span style="font-size:0.75rem;font-weight:700;color:var(--text-dim);min-width:24px;">TL:</span>
        <select class="quick-select" id="qa3TLCat" onchange="updateDualCatVisibility('qa3TL')"><option value="screw">Screw</option><option value="nut">Nut</option><option value="washer">Washer</option></select>
        <select class="quick-select" id="qa3TLSize"><option value="">Size</option></select>
        <input type="number" class="qty-input" id="qa3TLLength" placeholder="mm" min="1" max="200" list="qa3TLLengthSuggestions" style="width:70px">
        <datalist id="qa3TLLengthSuggestions"></datalist>
        <select class="quick-select" id="qa3TLHead"><option value="">Head</option></select>
        <select class="quick-select" id="qa3TLDrive"><option value="">Drive</option></select>
        <select class="quick-select" id="qa3TLMat"><option value="">Material</option></select>
      </div>
      <div class="quick-add-row" style="margin-bottom:0.3rem;">
        <span style="font-size:0.75rem;font-weight:700;color:var(--text-dim);min-width:24px;">TR:</span>
        <select class="quick-select" id="qa3TRCat" onchange="updateDualCatVisibility('qa3TR')"><option value="screw">Screw</option><option value="nut">Nut</option><option value="washer">Washer</option></select>
        <select class="quick-select" id="qa3TRSize"><option value="">Size</option></select>
        <input type="number" class="qty-input" id="qa3TRLength" placeholder="mm" min="1" max="200" list="qa3TRLengthSuggestions" style="width:70px">
        <datalist id="qa3TRLengthSuggestions"></datalist>
        <select class="quick-select" id="qa3TRHead"><option value="">Head</option></select>
        <select class="quick-select" id="qa3TRDrive"><option value="">Drive</option></select>
        <select class="quick-select" id="qa3TRMat"><option value="">Material</option></select>
      </div>
      <div class="quick-add-row" style="margin-bottom:0.3rem;">
        <span style="font-size:0.75rem;font-weight:700;color:var(--text-dim);min-width:24px;">B:</span>
        <select class="quick-select" id="qa3BCat" onchange="updateDualCatVisibility('qa3B')"><option value="screw">Screw</option><option value="nut">Nut</option><option value="washer">Washer</option></select>
        <select class="quick-select" id="qa3BSize"><option value="">Size</option></select>
        <input type="number" class="qty-input" id="qa3BLength" placeholder="mm" min="1" max="200" list="qa3BLengthSuggestions" style="width:70px">
        <datalist id="qa3BLengthSuggestions"></datalist>
        <select class="quick-select" id="qa3BHead"><option value="">Head</option></select>
        <select class="quick-select" id="qa3BDrive"><option value="">Drive</option></select>
        <select class="quick-select" id="qa3BMat"><option value="">Material</option></select>
      </div>
      <div class="quick-add-row" style="justify-content:flex-end;">
        <label style="font-size:0.72rem;color:var(--text-muted);display:flex;align-items:center;gap:0.3rem;">
          Qty: <input type="number" class="qty-input" id="qaTripleQty" value="1" min="1" max="20">
        </label>
        <button class="btn btn-primary btn-sm" onclick="quickAdd()">+ Add</button>
      </div>
    </div>
    <div id="qaQuadRows" style="display:none">
      <div class="quick-add-row" style="margin-bottom:0.3rem;">
        <span style="font-size:0.75rem;font-weight:700;color:var(--text-dim);min-width:24px;">TL:</span>
        <select class="quick-select" id="qa4TLCat" onchange="updateDualCatVisibility('qa4TL')"><option value="screw">Screw</option><option value="nut">Nut</option><option value="washer">Washer</option></select>
        <select class="quick-select" id="qa4TLSize"><option value="">Size</option></select>
        <input type="number" class="qty-input" id="qa4TLLength" placeholder="mm" min="1" max="200" list="qa4TLLengthSuggestions" style="width:70px">
        <datalist id="qa4TLLengthSuggestions"></datalist>
        <select class="quick-select" id="qa4TLHead"><option value="">Head</option></select>
        <select class="quick-select" id="qa4TLDrive"><option value="">Drive</option></select>
        <select class="quick-select" id="qa4TLMat"><option value="">Material</option></select>
      </div>
      <div class="quick-add-row" style="margin-bottom:0.3rem;">
        <span style="font-size:0.75rem;font-weight:700;color:var(--text-dim);min-width:24px;">TR:</span>
        <select class="quick-select" id="qa4TRCat" onchange="updateDualCatVisibility('qa4TR')"><option value="screw">Screw</option><option value="nut">Nut</option><option value="washer">Washer</option></select>
        <select class="quick-select" id="qa4TRSize"><option value="">Size</option></select>
        <input type="number" class="qty-input" id="qa4TRLength" placeholder="mm" min="1" max="200" list="qa4TRLengthSuggestions" style="width:70px">
        <datalist id="qa4TRLengthSuggestions"></datalist>
        <select class="quick-select" id="qa4TRHead"><option value="">Head</option></select>
        <select class="quick-select" id="qa4TRDrive"><option value="">Drive</option></select>
        <select class="quick-select" id="qa4TRMat"><option value="">Material</option></select>
      </div>
      <div class="quick-add-row" style="margin-bottom:0.3rem;">
        <span style="font-size:0.75rem;font-weight:700;color:var(--text-dim);min-width:24px;">BL:</span>
        <select class="quick-select" id="qa4BLCat" onchange="updateDualCatVisibility('qa4BL')"><option value="screw">Screw</option><option value="nut">Nut</option><option value="washer">Washer</option></select>
        <select class="quick-select" id="qa4BLSize"><option value="">Size</option></select>
        <input type="number" class="qty-input" id="qa4BLLength" placeholder="mm" min="1" max="200" list="qa4BLLengthSuggestions" style="width:70px">
        <datalist id="qa4BLLengthSuggestions"></datalist>
        <select class="quick-select" id="qa4BLHead"><option value="">Head</option></select>
        <select class="quick-select" id="qa4BLDrive"><option value="">Drive</option></select>
        <select class="quick-select" id="qa4BLMat"><option value="">Material</option></select>
      </div>
      <div class="quick-add-row" style="margin-bottom:0.3rem;">
        <span style="font-size:0.75rem;font-weight:700;color:var(--text-dim);min-width:24px;">BR:</span>
        <select class="quick-select" id="qa4BRCat" onchange="updateDualCatVisibility('qa4BR')"><option value="screw">Screw</option><option value="nut">Nut</option><option value="washer">Washer</option></select>
        <select class="quick-select" id="qa4BRSize"><option value="">Size</option></select>
        <input type="number" class="qty-input" id="qa4BRLength" placeholder="mm" min="1" max="200" list="qa4BRLengthSuggestions" style="width:70px">
        <datalist id="qa4BRLengthSuggestions"></datalist>
        <select class="quick-select" id="qa4BRHead"><option value="">Head</option></select>
        <select class="quick-select" id="qa4BRDrive"><option value="">Drive</option></select>
        <select class="quick-select" id="qa4BRMat"><option value="">Material</option></select>
      </div>
      <div class="quick-add-row" style="justify-content:flex-end;">
        <label style="font-size:0.72rem;color:var(--text-muted);display:flex;align-items:center;gap:0.3rem;">
          Qty: <input type="number" class="qty-input" id="qaQuadQty" value="1" min="1" max="20">
        </label>
        <button class="btn btn-primary btn-sm" onclick="quickAdd()">+ Add</button>
      </div>
    </div>
  </div>

  <div class="label-grid" id="labelGrid"></div>
  <div class="empty-state" id="emptyState" style="display:none;">
    <div class="empty-icon">ğŸ”©</div>
    <p>No labels match your filters.<br>Adjust the sidebar filters to see labels.</p>
  </div>
</div>
</div>

<!-- PRINT SHEET MODAL -->
<div class="modal-overlay" id="printModal">
  <div class="modal">
    <h2>ğŸ–¨ï¸ Print Preview</h2>
    <p style="font-size:0.78rem;color:var(--text-dim);margin-bottom:0.8rem;">
      Labels are laid out on Letter pages (8.5Ã—11") at 40Ã—16mm each. Print at 100% scale on sticker paper, then cut.
    </p>
    <div id="sheetContainer"></div>
    <div class="modal-actions">
      <button class="btn btn-secondary" onclick="closePrintModal()">Close</button>
      <button class="btn btn-primary" onclick="downloadSheetPDF()">ğŸ’¾ Download as Images</button>
      <button class="btn btn-primary" onclick="printSheets()">ğŸ–¨ï¸ Print</button>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SIZES = ['M2','M2.5','M3','M4','M5','M6'];
const SIZE_BARS = {M2:1,'M2.5':2,M3:3,M4:4,M5:5,M6:6};
const SIZE_LENGTHS = {
  M2:[3,4,5,6,8,10,12,14,16,18,20],
  'M2.5':[4,5,6,8,10,12,14,16,18,20,25],
  M3:[4,5,6,8,10,12,14,16,18,20,25,30],
  M4:[4,5,6,8,10,12,14,16,18,20,25,30,35,40,45,50],
  M5:[6,8,10,12,14,16,18,20,25,30,35,40,45,50],
  M6:[8,10,12,14,16,18,20,25,30,35,40,45,50,55,60]
};
const ALL_LENGTHS = [...new Set(Object.values(SIZE_LENGTHS).flat())].sort((a,b)=>a-b);
const HEADS = {CAP:{full:'Cap Head'},BTN:{full:'Button Head'},CSK:{full:'Countersunk'},RCSK:{full:'Raised Countersunk'}};
const DRIVES = {PH:'Phillips',HX:'Hex'};
const DRIVES_ABBR = {PH:'PH',HX:'HEX'};
const MATS = ['Black','Stainless'];

// Label dimensions at 300dpi
const LW = 472, LH = 189;
// US Letter (8.5"Ã—11") at 300dpi
const PW = 2550, PH_PAGE = 3300;
const MARGIN = 50, GAP_X = 10, GAP_Y = 6;
const COLS = Math.floor((PW - 2*MARGIN + GAP_X)/(LW+GAP_X));
const ROWS = Math.floor((PH_PAGE - 2*MARGIN + GAP_Y)/(LH+GAP_Y));
const PER_PAGE = COLS * ROWS;

// State
let filters = { cat:new Set(['screw','nut','washer']), size:new Set(SIZES), head:new Set(Object.keys(HEADS)),
  drive:new Set(['PH','HX']), mat:new Set(MATS), len:new Set(ALL_LENGTHS) };
let selectedLabels = new Map(); // key -> {config, qty}
let allLabels = []; // generated label configs
let quickAddMode = 'single'; // 'single', 'dual', 'triple', or 'quad'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CANVAS LABEL DRAWING (matches the Python output exactly)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawLabel(canvas, cfg) {
  if (cfg.cat === 'triple') { drawTripleLabel(canvas, cfg); return; }
  if (cfg.cat === 'quad') { drawQuadLabel(canvas, cfg); return; }
  if (cfg.cat === 'dual') { drawDualLabel(canvas, cfg); return; }
  canvas.width = LW; canvas.height = LH;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, LW, LH);

  // Top bars: full width, taller
  const barCount = SIZE_BARS[cfg.size];
  const barH = 14, barGap = 4;
  const totalBarW = LW - 8; // 4px margin each side
  const barW = Math.floor((totalBarW - (barCount - 1) * barGap) / barCount);
  ctx.fillStyle = 'black';
  for (let i=0; i<barCount; i++) {
    ctx.fillRect(4 + i*(barW+barGap), 3, barW, barH);
  }

  const ctop = 3 + barH + 4;

  // Text zone (left 52%)
  const tzW = Math.floor(LW * 0.52);
  const tx = 8;
  ctx.fillStyle = 'black';

  if (cfg.cat === 'screw') {
    // Line 1: M3 x 50
    ctx.font = 'bold 62px "DejaVu Sans", sans-serif';
    ctx.fillText(cfg.size + ' x ' + cfg.length, tx, ctop + 48);

    // Line 2: HEX CAP
    ctx.font = 'bold 32px "DejaVu Sans", sans-serif';
    ctx.fillText((DRIVES_ABBR[cfg.drive]||cfg.drive) + ' ' + cfg.head, tx, ctop + 80);

    // Line 3: Socket: Hex
    ctx.font = '22px "DejaVu Sans", sans-serif';
    ctx.fillText('Socket: ' + DRIVES[cfg.drive], tx, ctop + 104);

    // Line 4: Head: Cap Head (with overflow protection)
    const headText = 'Head: ' + HEADS[cfg.head].full;
    ctx.font = '22px "DejaVu Sans", sans-serif';
    if (ctx.measureText(headText).width > tzW - tx - 8) {
      ctx.font = '18px "DejaVu Sans", sans-serif';
      if (ctx.measureText(headText).width > tzW - tx - 8) {
        ctx.font = '16px "DejaVu Sans", sans-serif';
      }
    }
    ctx.fillText(headText, tx, ctop + 126);

    // Line 5: Material
    ctx.font = 'bold 22px "DejaVu Sans", sans-serif';
    ctx.fillText(cfg.material, tx, ctop + 150);
  } else {
    // Hardware label
    ctx.font = 'bold 62px "DejaVu Sans", sans-serif';
    ctx.fillText(cfg.size, tx, ctop + 48);

    ctx.font = 'bold 32px "DejaVu Sans", sans-serif';
    const hwAbbr = cfg.cat === 'nut' ? 'NUT' : 'WASHER';
    ctx.fillText(hwAbbr, tx, ctop + 80);

    ctx.font = '22px "DejaVu Sans", sans-serif';
    const hwFull = cfg.cat === 'nut' ? 'Hex Nut' : 'Flat Washer';
    ctx.fillText(hwFull, tx, ctop + 104);

    ctx.font = 'bold 22px "DejaVu Sans", sans-serif';
    ctx.fillText(cfg.material, tx, ctop + 128);
  }

  // Divider
  const divX = tzW - 4;
  ctx.strokeStyle = 'black'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(divX, ctop+2); ctx.lineTo(divX, LH-6); ctx.stroke();

  // Drawing zone
  const dzStart = tzW;
  const dzW = LW - dzStart - 4;
  const tdZW = Math.floor(dzW * 0.48);
  const sideZW = dzW - tdZW;
  const contentH = LH - ctop - 4;
  const tdCx = dzStart + tdZW/2;
  const tdCy = ctop + contentH/2;
  const tdR = Math.min(tdZW*0.42, contentH*0.42);

  const filled = cfg.material === 'Black';

  if (cfg.cat === 'screw') {
    drawTopDown(ctx, tdCx, tdCy, tdR, cfg.head, cfg.drive, filled);
    drawSideProfile(ctx, dzStart+tdZW, ctop+2, sideZW-4, contentH-4, cfg.head, filled);
  } else if (cfg.cat === 'nut') {
    drawNutTopDown(ctx, tdCx, tdCy, tdR, filled);
    drawNutSide(ctx, dzStart+tdZW, ctop+2, sideZW-4, contentH-4, filled);
  } else {
    drawWasherTopDown(ctx, tdCx, tdCy, tdR, filled);
    drawWasherSide(ctx, dzStart+tdZW, ctop+2, sideZW-4, contentH-4, filled);
  }

  // Border
  ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
  ctx.strokeRect(1, 1, LW-2, LH-2);
}

// Top-down views
function drawTopDown(ctx, cx, cy, r, head, drive, filled) {
  if (filled) {
    ctx.fillStyle='black';
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='white';
  } else {
    ctx.strokeStyle='black'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
  }

  if (head==='CAP') {
    ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,r*0.78,0,Math.PI*2); ctx.stroke();
    drawDriveTopDown(ctx,cx,cy,r*0.42,drive,filled);
  } else if (head==='BTN') {
    ctx.lineWidth=1; ctx.beginPath(); ctx.arc(cx,cy,r*0.70,0,Math.PI*2); ctx.stroke();
    drawDriveTopDown(ctx,cx,cy,r*0.32,drive,filled);
  } else if (head==='CSK') {
    ctx.lineWidth=1;
    for (const f of [0.70,0.45]) { ctx.beginPath(); ctx.arc(cx,cy,r*f,0,Math.PI*2); ctx.stroke(); }
    drawDriveTopDown(ctx,cx,cy,r*0.35,drive,filled);
  } else { // RCSK
    ctx.lineWidth=1; ctx.beginPath(); ctx.arc(cx,cy,r*0.65,0,Math.PI*2); ctx.stroke();
    ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,r*0.42,0,Math.PI*2); ctx.stroke();
    drawDriveTopDown(ctx,cx,cy,r*0.28,drive,filled);
  }
}

function drawDriveTopDown(ctx, cx, cy, r, drive, filled) {
  ctx.fillStyle = filled ? 'white' : 'black';
  if (drive==='PH') {
    const lw = Math.max(3, r/3);
    ctx.fillRect(cx-lw/2, cy-r, lw, r*2);
    ctx.fillRect(cx-r, cy-lw/2, r*2, lw);
  } else {
    ctx.beginPath();
    for (let i=0;i<6;i++) {
      const a = (60*i-30)*Math.PI/180;
      const px=cx+r*Math.cos(a), py=cy+r*Math.sin(a);
      i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
    }
    ctx.closePath(); ctx.fill();
  }
}

// Side profiles
function drawSideProfile(ctx, x0, y0, w, h, head, filled) {
  const cx = x0+w/2;
  const sL=cx-w*0.15, sR=cx+w*0.15, sB=y0+h*0.88, tip=y0+h*0.96;

  if (filled) {
    ctx.fillStyle='black';
    let threadTop;
    ctx.beginPath();
    if (head==='CAP') {
      const hL=cx-w*0.30,hR=cx+w*0.30,hT=y0+h*0.04,hB=y0+h*0.37,ch=w*0.04;
      threadTop=hB+8;
      ctx.moveTo(hL+ch,hT); ctx.lineTo(hR-ch,hT); ctx.lineTo(hR,hT+ch);
      ctx.lineTo(hR,hB); ctx.lineTo(sR,hB); ctx.lineTo(sR,sB);
      ctx.lineTo(cx,tip); ctx.lineTo(sL,sB); ctx.lineTo(sL,hB);
      ctx.lineTo(hL,hB); ctx.lineTo(hL,hT+ch);
    } else if (head==='BTN') {
      const dL=cx-w*0.40,dR=cx+w*0.40,base=y0+h*0.35,dT=y0+h*0.04;
      threadTop=base+8;
      ctx.ellipse(cx,(dT+base+h*0.28)/2,(dR-dL)/2+w*0.02,(base+h*0.28-dT)/2,0,Math.PI+0.035,-0.035);
      ctx.lineTo(sR,base); ctx.lineTo(sR,sB);
      ctx.lineTo(cx,tip); ctx.lineTo(sL,sB); ctx.lineTo(sL,base);
    } else if (head==='CSK') {
      const hL=cx-w*0.42,hR=cx+w*0.42,hT=y0+h*0.16,hB=y0+h*0.38;
      threadTop=hB+8;
      ctx.moveTo(hL,hT); ctx.lineTo(hR,hT); ctx.lineTo(sR,hB);
      ctx.lineTo(sR,sB); ctx.lineTo(cx,tip); ctx.lineTo(sL,sB); ctx.lineTo(sL,hB);
    } else { // RCSK
      const hL=cx-w*0.42,hR=cx+w*0.42,asY=y0+h*0.22,hB=y0+h*0.40,dA=y0+h*0.04;
      threadTop=hB+8;
      ctx.ellipse(cx,(dA+asY+h*0.16)/2,(hR-hL)/2+w*0.02,(asY+h*0.16-dA)/2,0,Math.PI+0.035,-0.035);
      ctx.lineTo(sR,hB); ctx.lineTo(sR,sB);
      ctx.lineTo(cx,tip); ctx.lineTo(sL,sB); ctx.lineTo(sL,hB);
    }
    ctx.closePath(); ctx.fill();
    drawThreads(ctx,sL,sR,threadTop,sB,true);
  } else {
    ctx.strokeStyle='black'; ctx.lineWidth=3;
    if (head==='CAP') {
      const hL=cx-w*0.30,hR=cx+w*0.30,hT=y0+h*0.04,hB=y0+h*0.37;
      ctx.strokeRect(hL,hT,hR-hL,hB-hT);
      const ch=w*0.04;
      ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(hL,hT+ch);ctx.lineTo(hL+ch,hT);ctx.stroke();
      ctx.beginPath();ctx.moveTo(hR,hT+ch);ctx.lineTo(hR-ch,hT);ctx.stroke();
      ctx.lineWidth=3;
      ctx.beginPath();ctx.moveTo(sL,hB);ctx.lineTo(sL,sB);ctx.stroke();
      ctx.beginPath();ctx.moveTo(sR,hB);ctx.lineTo(sR,sB);ctx.stroke();
      drawThreads(ctx,sL,sR,hB+8,sB,false);
      drawTip(ctx,sL,sR,sB,cx,tip);
    } else if (head==='BTN') {
      const dL=cx-w*0.40,dR=cx+w*0.40,base=y0+h*0.35,dT=y0+h*0.04;
      ctx.beginPath();ctx.ellipse(cx,(dT+base+h*0.28)/2,(dR-dL)/2+w*0.02,(base+h*0.28-dT)/2,0,Math.PI+0.035,-0.035);ctx.stroke();
      ctx.beginPath();ctx.moveTo(dL,base);ctx.lineTo(dR,base);ctx.stroke();
      ctx.beginPath();ctx.moveTo(sL,base);ctx.lineTo(sL,sB);ctx.stroke();
      ctx.beginPath();ctx.moveTo(sR,base);ctx.lineTo(sR,sB);ctx.stroke();
      drawThreads(ctx,sL,sR,base+8,sB,false);
      drawTip(ctx,sL,sR,sB,cx,tip);
    } else if (head==='CSK') {
      const hL=cx-w*0.42,hR=cx+w*0.42,hT=y0+h*0.16,hB=y0+h*0.38;
      ctx.beginPath();ctx.moveTo(hL,hT);ctx.lineTo(hR,hT);ctx.stroke();
      ctx.beginPath();ctx.moveTo(hL,hT);ctx.lineTo(sL,hB);ctx.stroke();
      ctx.beginPath();ctx.moveTo(hR,hT);ctx.lineTo(sR,hB);ctx.stroke();
      ctx.beginPath();ctx.moveTo(sL,hB);ctx.lineTo(sL,sB);ctx.stroke();
      ctx.beginPath();ctx.moveTo(sR,hB);ctx.lineTo(sR,sB);ctx.stroke();
      drawThreads(ctx,sL,sR,hB+8,sB,false);
      drawTip(ctx,sL,sR,sB,cx,tip);
    } else { // RCSK
      const hL=cx-w*0.42,hR=cx+w*0.42,asY=y0+h*0.22,hB=y0+h*0.40,dA=y0+h*0.04;
      ctx.beginPath();ctx.ellipse(cx,(dA+asY+h*0.16)/2,(hR-hL)/2+w*0.02,(asY+h*0.16-dA)/2,0,Math.PI+0.035,-0.035);ctx.stroke();
      ctx.beginPath();ctx.moveTo(hL,asY);ctx.lineTo(sL,hB);ctx.stroke();
      ctx.beginPath();ctx.moveTo(hR,asY);ctx.lineTo(sR,hB);ctx.stroke();
      ctx.beginPath();ctx.moveTo(sL,hB);ctx.lineTo(sL,sB);ctx.stroke();
      ctx.beginPath();ctx.moveTo(sR,hB);ctx.lineTo(sR,sB);ctx.stroke();
      drawThreads(ctx,sL,sR,hB+8,sB,false);
      drawTip(ctx,sL,sR,sB,cx,tip);
    }
  }
}

function drawThreads(ctx, l, r, top, bot, filled) {
  ctx.lineWidth=1; ctx.strokeStyle = filled ? 'white' : 'black';
  for (let y=top; y<bot-2; y+=7) {
    ctx.beginPath(); ctx.moveTo(l+2,y); ctx.lineTo(r-2,y+1); ctx.stroke();
  }
  ctx.lineWidth=3;
}

function drawTip(ctx, l, r, bot, cx, tip) {
  ctx.lineWidth=3; ctx.strokeStyle='black';
  ctx.beginPath(); ctx.moveTo(l,bot); ctx.lineTo(cx,tip); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(r,bot); ctx.lineTo(cx,tip); ctx.stroke();
}

function drawNutTopDown(ctx, cx, cy, r, filled) {
  if (filled) {
    ctx.fillStyle='black';
    ctx.beginPath();
    for (let i=0;i<6;i++) {
      const a=60*i*Math.PI/180;
      const px=cx+r*Math.cos(a),py=cy+r*Math.sin(a);
      i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
    }
    ctx.closePath(); ctx.fill();
    ctx.fillStyle='white';
    ctx.beginPath(); ctx.arc(cx,cy,r*0.38,0,Math.PI*2); ctx.fill();
  } else {
    ctx.strokeStyle='black'; ctx.lineWidth=3;
    ctx.beginPath();
    for (let i=0;i<6;i++) {
      const a=60*i*Math.PI/180;
      const px=cx+r*Math.cos(a),py=cy+r*Math.sin(a);
      i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
    }
    ctx.closePath(); ctx.stroke();
    ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,r*0.38,0,Math.PI*2); ctx.stroke();
  }
}

function drawNutSide(ctx, x0, y0, w, h, filled) {
  const cx=x0+w/2, hw=w*0.34, hh=h*0.22, ch=w*0.06;
  const top=y0+h*0.28, bot=top+2*hh;
  if (filled) {
    ctx.fillStyle='black';
    ctx.beginPath();
    ctx.moveTo(cx-hw+ch,top); ctx.lineTo(cx+hw-ch,top); ctx.lineTo(cx+hw,top+ch);
    ctx.lineTo(cx+hw,bot); ctx.lineTo(cx-hw,bot); ctx.lineTo(cx-hw,top+ch);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle='white'; ctx.lineWidth=1;
    const pw=w*0.12;
    ctx.beginPath();ctx.moveTo(cx-pw,top);ctx.lineTo(cx-pw,bot);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx+pw,top);ctx.lineTo(cx+pw,bot);ctx.stroke();
  } else {
    ctx.strokeStyle='black'; ctx.lineWidth=3;
    ctx.strokeRect(cx-hw,top+ch,hw*2,bot-top-ch);
    ctx.beginPath();ctx.moveTo(cx-hw,top+ch);ctx.lineTo(cx-hw+ch,top);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx-hw+ch,top);ctx.lineTo(cx+hw-ch,top);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx+hw-ch,top);ctx.lineTo(cx+hw,top+ch);ctx.stroke();
    ctx.lineWidth=1;
    const pw=w*0.12;
    ctx.beginPath();ctx.moveTo(cx-pw,top);ctx.lineTo(cx-pw,bot);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx+pw,top);ctx.lineTo(cx+pw,bot);ctx.stroke();
  }
}

function drawWasherTopDown(ctx, cx, cy, r, filled) {
  if (filled) {
    ctx.fillStyle='black';
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='white';
    ctx.beginPath(); ctx.arc(cx,cy,r*0.40,0,Math.PI*2); ctx.fill();
  } else {
    ctx.strokeStyle='black'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
    ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,r*0.40,0,Math.PI*2); ctx.stroke();
  }
}

function drawWasherSide(ctx, x0, y0, w, h, filled) {
  const cx=x0+w/2, hw=w*0.40, hh=h*0.05, cy=y0+h/2;
  if (filled) {
    ctx.fillStyle='black';
    ctx.fillRect(cx-hw,cy-hh,hw*2,hh*2);
    ctx.strokeStyle='white'; ctx.lineWidth=1;
    const pw=w*0.14;
    ctx.beginPath();ctx.moveTo(cx-pw,cy-hh);ctx.lineTo(cx-pw,cy+hh);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx+pw,cy-hh);ctx.lineTo(cx+pw,cy+hh);ctx.stroke();
  } else {
    ctx.strokeStyle='black'; ctx.lineWidth=3;
    ctx.strokeRect(cx-hw,cy-hh,hw*2,hh*2);
    ctx.lineWidth=1;
    const pw=w*0.14;
    ctx.beginPath();ctx.moveTo(cx-pw,cy-hh);ctx.lineTo(cx-pw,cy+hh);ctx.stroke();
    ctx.beginPath();ctx.moveTo(cx+pw,cy-hh);ctx.lineTo(cx+pw,cy+hh);ctx.stroke();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DUAL LABEL DRAWING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawDualLabel(canvas, cfg) {
  canvas.width = LW; canvas.height = LH;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, LW, LH);

  const halfW = Math.floor(LW / 2);

  // Draw each half
  drawDualHalf(ctx, cfg.left, 0, halfW);
  drawDualHalf(ctx, cfg.right, halfW, halfW);

  // Center divider â€” bold dashed line
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 3;
  ctx.setLineDash([8, 4]);
  ctx.beginPath();
  ctx.moveTo(halfW, 4);
  ctx.lineTo(halfW, LH - 4);
  ctx.stroke();
  ctx.setLineDash([]);

  // Border
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.strokeRect(1, 1, LW - 2, LH - 2);
}

function drawDualHalf(ctx, side, x0, w) {
  // Bars at top
  const barCount = SIZE_BARS[side.size];
  const barH = 10, barGap = 3;
  const barAreaW = w - 8;
  const barW = Math.floor((barAreaW - (barCount - 1) * barGap) / barCount);
  ctx.fillStyle = 'black';
  for (let i = 0; i < barCount; i++) {
    ctx.fillRect(x0 + 4 + i * (barW + barGap), 3, barW, barH);
  }

  const ctop = 3 + barH + 2;
  const tx = x0 + 6;
  const textZoneW = Math.floor(w * 0.58);
  const maxTextW = textZoneW - 10;
  ctx.fillStyle = 'black';

  if (side.cat === 'screw') {
    // Size x Length
    ctx.font = 'bold 34px "DejaVu Sans", sans-serif';
    const sizeText = side.size + ' x ' + side.length;
    if (ctx.measureText(sizeText).width > maxTextW) {
      ctx.font = 'bold 28px "DejaVu Sans", sans-serif';
    }
    ctx.fillText(sizeText, tx, ctop + 30);

    // DRIVE HEAD
    ctx.font = 'bold 20px "DejaVu Sans", sans-serif';
    ctx.fillText((DRIVES_ABBR[side.drive] || side.drive) + ' ' + side.head, tx, ctop + 54);

    // Material
    ctx.font = 'bold 16px "DejaVu Sans", sans-serif';
    ctx.fillText(side.material, tx, ctop + 76);
  } else {
    // Nut or Washer
    ctx.font = 'bold 34px "DejaVu Sans", sans-serif';
    ctx.fillText(side.size, tx, ctop + 30);

    const hwAbbr = side.cat === 'nut' ? 'NUT' : 'WASHER';
    ctx.font = 'bold 20px "DejaVu Sans", sans-serif';
    ctx.fillText(hwAbbr, tx, ctop + 54);

    ctx.font = 'bold 16px "DejaVu Sans", sans-serif';
    ctx.fillText(side.material, tx, ctop + 76);
  }

  // Drawing zone: top-down icon + side profile
  const dzStart = x0 + textZoneW;
  const dzW = w - textZoneW - 4;
  const contentH = LH - ctop - 6;
  const tdZoneW = Math.floor(dzW * 0.50);
  const sideZoneW = dzW - tdZoneW;
  const tdCx = dzStart + tdZoneW / 2;
  const tdCy = ctop + contentH / 2;
  const tdR = Math.min(tdZoneW * 0.42, contentH * 0.42);
  const filled = side.material === 'Black';

  if (side.cat === 'screw') {
    drawTopDown(ctx, tdCx, tdCy, tdR, side.head, side.drive, filled);
  } else if (side.cat === 'nut') {
    drawNutTopDown(ctx, tdCx, tdCy, tdR, filled);
  } else {
    drawWasherTopDown(ctx, tdCx, tdCy, tdR, filled);
  }

  // Side profile
  const spX = dzStart + tdZoneW;
  const spW = sideZoneW - 2;
  const spY = ctop + 1;
  const spH = contentH - 2;

  if (side.cat === 'screw') {
    drawSideProfile(ctx, spX, spY, spW, spH, side.head, filled);
  } else if (side.cat === 'nut') {
    drawNutSide(ctx, spX, spY, spW, spH, filled);
  } else {
    drawWasherSide(ctx, spX, spY, spW, spH, filled);
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRIPLE & QUAD LABEL DRAWING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawCompactCell(ctx, side, x0, y0, w, h, centered) {
  // Size bars at top - always span full cell width
  const barCount = SIZE_BARS[side.size];
  const barH = 6, barGap = 2;
  const barAreaW = w - 6;
  const barW = Math.floor((barAreaW - (barCount - 1) * barGap) / barCount);
  ctx.fillStyle = 'black';
  for (let i = 0; i < barCount; i++) {
    ctx.fillRect(x0 + 3 + i * (barW + barGap), y0 + 2, barW, barH);
  }

  const ctop = y0 + 2 + barH + 2;
  ctx.fillStyle = 'black';

  // Consistent font sizes across all cells
  const sizePx = 22, typePx = 14, matPx = 12;

  // For centered wide cells, use quarter-cell proportions centered in the space
  const contentW = (centered && w > 300) ? Math.floor(LW / 2) : w;
  const cx0 = (centered && w > 300) ? x0 + Math.floor((w - contentW) / 2) : x0;

  // Layout: text | top-down icon | side profile
  const textZoneW = Math.floor(contentW * 0.52);
  const drawZoneW = contentW - textZoneW;
  const tdZoneW = Math.floor(drawZoneW * 0.50);
  const sideZoneW = drawZoneW - tdZoneW;

  const tx = cx0 + 4;
  const maxTextW = textZoneW - 8;

  if (side.cat === 'screw') {
    ctx.font = `bold ${sizePx}px "DejaVu Sans", sans-serif`;
    const sizeText = side.size + ' x ' + side.length;
    if (ctx.measureText(sizeText).width > maxTextW) {
      ctx.font = `bold ${sizePx - 4}px "DejaVu Sans", sans-serif`;
    }
    ctx.fillText(sizeText, tx, ctop + sizePx);

    ctx.font = `bold ${typePx}px "DejaVu Sans", sans-serif`;
    ctx.fillText((DRIVES_ABBR[side.drive] || side.drive) + ' ' + side.head, tx, ctop + sizePx + typePx + 4);

    ctx.font = `bold ${matPx}px "DejaVu Sans", sans-serif`;
    ctx.fillText(side.material, tx, ctop + sizePx + typePx + matPx + 8);
  } else {
    ctx.font = `bold ${sizePx}px "DejaVu Sans", sans-serif`;
    ctx.fillText(side.size, tx, ctop + sizePx);

    const hwAbbr = side.cat === 'nut' ? 'NUT' : 'WASHER';
    ctx.font = `bold ${typePx}px "DejaVu Sans", sans-serif`;
    ctx.fillText(hwAbbr, tx, ctop + sizePx + typePx + 4);

    ctx.font = `bold ${matPx}px "DejaVu Sans", sans-serif`;
    ctx.fillText(side.material, tx, ctop + sizePx + typePx + matPx + 8);
  }

  // Drawing zones
  const dzStart = cx0 + textZoneW;
  const contentH = h - (ctop - y0) - 3;
  const filled = side.material === 'Black';

  // Top-down icon
  const tdCx = dzStart + tdZoneW / 2;
  const tdCy = ctop + contentH / 2;
  const tdR = Math.min(tdZoneW * 0.40, contentH * 0.40);

  if (side.cat === 'screw') {
    drawTopDown(ctx, tdCx, tdCy, tdR, side.head, side.drive, filled);
  } else if (side.cat === 'nut') {
    drawNutTopDown(ctx, tdCx, tdCy, tdR, filled);
  } else {
    drawWasherTopDown(ctx, tdCx, tdCy, tdR, filled);
  }

  // Side profile icon
  const spX = dzStart + tdZoneW;
  const spW = sideZoneW - 3;
  const spY = ctop + 1;
  const spH = contentH - 2;

  if (side.cat === 'screw') {
    drawSideProfile(ctx, spX, spY, spW, spH, side.head, filled);
  } else if (side.cat === 'nut') {
    drawNutSide(ctx, spX, spY, spW, spH, filled);
  } else {
    drawWasherSide(ctx, spX, spY, spW, spH, filled);
  }
}

function drawTripleLabel(canvas, cfg) {
  canvas.width = LW; canvas.height = LH;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, LW, LH);

  const halfW = Math.floor(LW / 2);
  const halfH = Math.floor(LH / 2);

  drawCompactCell(ctx, cfg.topLeft, 0, 0, halfW, halfH);
  drawCompactCell(ctx, cfg.topRight, halfW, 0, halfW, halfH);
  drawCompactCell(ctx, cfg.bottom, 0, halfH, LW, LH - halfH, true);

  // Dashed vertical divider in top half
  ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.setLineDash([6, 3]);
  ctx.beginPath(); ctx.moveTo(halfW, 3); ctx.lineTo(halfW, halfH - 1); ctx.stroke();

  // Dashed horizontal divider full width
  ctx.beginPath(); ctx.moveTo(3, halfH); ctx.lineTo(LW - 3, halfH); ctx.stroke();
  ctx.setLineDash([]);

  // Border
  ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
  ctx.strokeRect(1, 1, LW - 2, LH - 2);
}

function drawQuadLabel(canvas, cfg) {
  canvas.width = LW; canvas.height = LH;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, LW, LH);

  const halfW = Math.floor(LW / 2);
  const halfH = Math.floor(LH / 2);

  drawCompactCell(ctx, cfg.topLeft, 0, 0, halfW, halfH);
  drawCompactCell(ctx, cfg.topRight, halfW, 0, halfW, halfH);
  drawCompactCell(ctx, cfg.bottomLeft, 0, halfH, halfW, LH - halfH);
  drawCompactCell(ctx, cfg.bottomRight, halfW, halfH, halfW, LH - halfH);

  // Dashed vertical divider
  ctx.strokeStyle = 'black'; ctx.lineWidth = 2; ctx.setLineDash([6, 3]);
  ctx.beginPath(); ctx.moveTo(halfW, 3); ctx.lineTo(halfW, LH - 3); ctx.stroke();

  // Dashed horizontal divider
  ctx.beginPath(); ctx.moveTo(3, halfH); ctx.lineTo(LW - 3, halfH); ctx.stroke();
  ctx.setLineDash([]);

  // Border
  ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
  ctx.strokeRect(1, 1, LW - 2, LH - 2);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LABEL GENERATION & FILTERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function getLabelKey(cfg) {
  if (cfg.cat==='triple') return 'TRI_' + getLabelKey(cfg.topLeft) + '__' + getLabelKey(cfg.topRight) + '__' + getLabelKey(cfg.bottom);
  if (cfg.cat==='quad') return 'QUAD_' + getLabelKey(cfg.topLeft) + '__' + getLabelKey(cfg.topRight) + '__' + getLabelKey(cfg.bottomLeft) + '__' + getLabelKey(cfg.bottomRight);
  if (cfg.cat==='dual') return 'DUAL_' + getLabelKey(cfg.left) + '__' + getLabelKey(cfg.right);
  if (cfg.cat==='screw') return `${cfg.size}x${cfg.length}_${cfg.head}_${cfg.drive}_${cfg.material}`;
  return `${cfg.size}_${cfg.cat}_${cfg.material}`;
}

function buildAllLabels() {
  allLabels = [];
  for (const size of SIZES) {
    // Screws
    for (const len of SIZE_LENGTHS[size]) {
      for (const head of Object.keys(HEADS)) {
        for (const drive of ['PH','HX']) {
          for (const mat of MATS) {
            allLabels.push({cat:'screw',size,length:len,head,drive,material:mat});
          }
        }
      }
    }
    // Hardware
    for (const mat of MATS) {
      allLabels.push({cat:'nut',size,material:mat});
      allLabels.push({cat:'washer',size,material:mat});
    }
  }
}

function matchesFilters(cfg) {
  if (cfg.cat === 'triple') return matchesFilters(cfg.topLeft) || matchesFilters(cfg.topRight) || matchesFilters(cfg.bottom);
  if (cfg.cat === 'quad') return matchesFilters(cfg.topLeft) || matchesFilters(cfg.topRight) || matchesFilters(cfg.bottomLeft) || matchesFilters(cfg.bottomRight);
  if (cfg.cat === 'dual') return matchesFilters(cfg.left) || matchesFilters(cfg.right);
  if (!filters.cat.has(cfg.cat)) return false;
  if (!filters.size.has(cfg.size)) return false;
  if (!filters.mat.has(cfg.material)) return false;
  if (cfg.cat==='screw') {
    if (!filters.head.has(cfg.head)) return false;
    if (!filters.drive.has(cfg.drive)) return false;
    if (!filters.len.has(cfg.length)) return false;
  }
  // Search box
  const q = document.getElementById('searchBox').value.toLowerCase().trim();
  if (q) {
    const searchStr = getLabelKey(cfg).toLowerCase() + ' ' +
      (cfg.cat==='screw' ? HEADS[cfg.head].full.toLowerCase() : cfg.cat) + ' ' +
      cfg.material.toLowerCase();
    const terms = q.split(/\s+/);
    for (const t of terms) { if (!searchStr.includes(t)) return false; }
  }
  return true;
}

function applyFilters() {
  const grid = document.getElementById('labelGrid');
  const empty = document.getElementById('emptyState');
  grid.innerHTML = '';
  let count = 0;

  // Limit display to first 200 matching labels for performance
  const MAX_DISPLAY = 200;
  let displayed = 0;

  for (const cfg of allLabels) {
    if (!matchesFilters(cfg)) continue;
    count++;
    if (displayed >= MAX_DISPLAY) continue;
    displayed++;

    const key = getLabelKey(cfg);
    const card = document.createElement('div');
    card.className = 'label-card' + (selectedLabels.has(key) ? ' selected' : '');
    card.onclick = () => toggleSelect(key, cfg, card);

    const canvas = document.createElement('canvas');
    drawLabel(canvas, cfg);
    card.appendChild(canvas);

    const info = document.createElement('div');
    info.className = 'label-info';
    info.innerHTML = `<span>${key}</span>`;
    if (selectedLabels.has(key)) {
      info.innerHTML += `<span style="color:var(--accent)">Ã—${selectedLabels.get(key).qty}</span>`;
    }
    card.appendChild(info);
    grid.appendChild(card);
  }

  document.getElementById('visibleCount').textContent =
    count > MAX_DISPLAY ? `(showing ${MAX_DISPLAY} of ${count})` : `(${count} labels)`;
  empty.style.display = count === 0 ? 'block' : 'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SELECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function toggleSelect(key, cfg, card) {
  if (selectedLabels.has(key)) {
    selectedLabels.delete(key);
    card.classList.remove('selected');
  } else {
    selectedLabels.set(key, {cfg, qty:1});
    card.classList.add('selected');
  }
  updateSelectionUI();
}

function selectAllVisible() {
  for (const cfg of allLabels) {
    if (!matchesFilters(cfg)) continue;
    const key = getLabelKey(cfg);
    if (!selectedLabels.has(key)) selectedLabels.set(key, {cfg, qty:1});
  }
  applyFilters();
  updateSelectionUI();
}

function clearSelection() {
  selectedLabels.clear();
  applyFilters();
  updateSelectionUI();
}

function updateSelectionUI() {
  let total = 0;
  for (const v of selectedLabels.values()) total += v.qty;
  document.getElementById('selectedCount').textContent = total;
  document.getElementById('btnGenSheet').disabled = total === 0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILTER TOGGLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function toggleFilter(type, val, el) {
  const numVal = type==='len' ? parseInt(val) : val;
  const set = filters[type];
  if (set.has(numVal)) { set.delete(numVal); el.classList.remove('active'); }
  else { set.add(numVal); el.classList.add('active'); }
  applyFilters();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PRINT SHEET GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function generateSheet() {
  const container = document.getElementById('sheetContainer');
  container.innerHTML = '';

  // Collect all labels with quantities
  const labels = [];
  for (const [key, {cfg, qty}] of selectedLabels) {
    for (let i=0; i<qty; i++) labels.push(cfg);
  }

  if (labels.length === 0) return;

  const pageCount = Math.ceil(labels.length / PER_PAGE);
  let idx = 0;

  for (let p=0; p<pageCount; p++) {
    const pageCanvas = document.createElement('canvas');
    pageCanvas.width = PW; pageCanvas.height = PH_PAGE;
    pageCanvas.className = 'sheet-preview';
    pageCanvas.style.width = '100%';
    pageCanvas.style.maxWidth = '700px';
    const pctx = pageCanvas.getContext('2d');
    pctx.fillStyle = 'white'; pctx.fillRect(0,0,PW,PH_PAGE);

    for (let row=0; row<ROWS && idx<labels.length; row++) {
      for (let col=0; col<COLS && idx<labels.length; col++) {
        const x = MARGIN + col*(LW+GAP_X);
        const y = MARGIN + row*(LH+GAP_Y);
        // Draw label onto temp canvas, then paste
        const tmpC = document.createElement('canvas');
        drawLabel(tmpC, labels[idx]);
        pctx.drawImage(tmpC, x, y);
        idx++;
      }
    }

    const pageLabel = document.createElement('div');
    pageLabel.style.cssText = 'font-size:0.72rem;color:var(--text-muted);margin:0.3rem 0;';
    pageLabel.textContent = `Page ${p+1} of ${pageCount} (${Math.min(PER_PAGE, labels.length - p*PER_PAGE)} labels)`;
    container.appendChild(pageLabel);
    container.appendChild(pageCanvas);
  }

  document.getElementById('printModal').classList.add('open');
}

function closePrintModal() { document.getElementById('printModal').classList.remove('open'); }

function printSheets() {
  const canvases = document.querySelectorAll('#sheetContainer canvas');
  const win = window.open('','_blank');
  win.document.write('<html><head><title>Screw Labels</title><style>@page{size:letter;margin:0}body{margin:0}img{width:8.5in;height:11in;page-break-after:always}</style></head><body>');
  canvases.forEach(c => { win.document.write(`<img src="${c.toDataURL('image/png')}">`); });
  win.document.write('</body></html>');
  win.document.close();
  win.onload = () => { win.print(); };
}

function downloadSheetPDF() {
  const canvases = document.querySelectorAll('#sheetContainer canvas');
  canvases.forEach((c, i) => {
    const link = document.createElement('a');
    link.download = `label_sheet_${i+1}.png`;
    link.href = c.toDataURL('image/png');
    link.click();
  });
}

function downloadSelected() {
  for (const [key, {cfg}] of selectedLabels) {
    const c = document.createElement('canvas');
    drawLabel(c, cfg);
    const link = document.createElement('a');
    link.download = key + '.png';
    link.href = c.toDataURL('image/png');
    link.click();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// QUICK ADD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function populateSideSelects(prefix) {
  const sizeEl = document.getElementById(prefix + 'Size');
  SIZES.forEach(s => { const o = document.createElement('option'); o.value=s; o.textContent=s; sizeEl.appendChild(o); });
  sizeEl.onchange = () => {
    const dl = document.getElementById(prefix + 'LengthSuggestions');
    dl.innerHTML = '';
    const lengths = SIZE_LENGTHS[sizeEl.value] || [];
    lengths.forEach(l => { const o = document.createElement('option'); o.value=l; dl.appendChild(o); });
    document.getElementById(prefix + 'Length').value = '';
  };
  const headEl = document.getElementById(prefix + 'Head');
  Object.entries(HEADS).forEach(([k,v]) => { const o = document.createElement('option'); o.value=k; o.textContent=`${k} - ${v.full}`; headEl.appendChild(o); });
  const driveEl = document.getElementById(prefix + 'Drive');
  Object.entries(DRIVES).forEach(([k,v]) => { const o = document.createElement('option'); o.value=k; o.textContent=`${k} - ${v}`; driveEl.appendChild(o); });
  const matEl = document.getElementById(prefix + 'Mat');
  MATS.forEach(m => { const o = document.createElement('option'); o.value=m; o.textContent=m; matEl.appendChild(o); });
}

function initQuickAdd() {
  populateSideSelects('qa');
  populateSideSelects('qaL');
  populateSideSelects('qaR');
  populateSideSelects('qa3TL');
  populateSideSelects('qa3TR');
  populateSideSelects('qa3B');
  populateSideSelects('qa4TL');
  populateSideSelects('qa4TR');
  populateSideSelects('qa4BL');
  populateSideSelects('qa4BR');
}

function buildSideConfig(prefix) {
  const catEl = document.getElementById(prefix + 'Cat');
  const cat = catEl ? catEl.value : 'screw';
  const size = document.getElementById(prefix + 'Size').value;
  const mat = document.getElementById(prefix + 'Mat').value;
  if (!size || !mat) return null;
  if (cat === 'screw') {
    const len = document.getElementById(prefix + 'Length').value;
    const head = document.getElementById(prefix + 'Head').value;
    const drive = document.getElementById(prefix + 'Drive').value;
    if (!len || !head || !drive) return null;
    return { cat:'screw', size, length:parseInt(len), head, drive, material:mat };
  }
  return { cat, size, material:mat };
}

function setQuickAddMode(mode) {
  quickAddMode = mode;
  document.getElementById('qaSingleRow').style.display = mode === 'single' ? 'flex' : 'none';
  document.getElementById('qaDualRows').style.display = mode === 'dual' ? 'block' : 'none';
  document.getElementById('qaTripleRows').style.display = mode === 'triple' ? 'block' : 'none';
  document.getElementById('qaQuadRows').style.display = mode === 'quad' ? 'block' : 'none';
  document.querySelectorAll('.mode-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.mode === mode);
  });
}

function updateDualCatVisibility(prefix) {
  const cat = document.getElementById(prefix + 'Cat').value;
  const isScrew = cat === 'screw';
  document.getElementById(prefix + 'Length').style.display = isScrew ? '' : 'none';
  document.getElementById(prefix + 'Head').style.display = isScrew ? '' : 'none';
  document.getElementById(prefix + 'Drive').style.display = isScrew ? '' : 'none';
}

function addMultiBinLabel(cfg, qtyId) {
  const qty = parseInt(document.getElementById(qtyId).value) || 1;
  const key = getLabelKey(cfg);
  if (!allLabels.some(l => getLabelKey(l) === key)) {
    allLabels.push(cfg);
    const custom = JSON.parse(localStorage.getItem('customLabels') || '[]');
    if (!custom.some(l => getLabelKey(l) === key)) {
      custom.push(cfg);
      localStorage.setItem('customLabels', JSON.stringify(custom));
    }
  }
  const subs = cfg.cat === 'dual' ? [cfg.left, cfg.right]
    : cfg.cat === 'triple' ? [cfg.topLeft, cfg.topRight, cfg.bottom]
    : [cfg.topLeft, cfg.topRight, cfg.bottomLeft, cfg.bottomRight];
  for (const s of subs) {
    if (s.cat === 'screw' && !filters.len.has(s.length)) filters.len.add(s.length);
  }
  selectedLabels.set(key, { cfg, qty });
  applyFilters();
  updateSelectionUI();
}

function quickAdd() {
  if (quickAddMode === 'quad') {
    const topLeft = buildSideConfig('qa4TL');
    const topRight = buildSideConfig('qa4TR');
    const bottomLeft = buildSideConfig('qa4BL');
    const bottomRight = buildSideConfig('qa4BR');
    if (!topLeft || !topRight || !bottomLeft || !bottomRight) { alert('Please fill all required fields for all four bins'); return; }
    addMultiBinLabel({ cat:'quad', topLeft, topRight, bottomLeft, bottomRight }, 'qaQuadQty');
    return;
  }
  if (quickAddMode === 'triple') {
    const topLeft = buildSideConfig('qa3TL');
    const topRight = buildSideConfig('qa3TR');
    const bottom = buildSideConfig('qa3B');
    if (!topLeft || !topRight || !bottom) { alert('Please fill all required fields for all three bins'); return; }
    addMultiBinLabel({ cat:'triple', topLeft, topRight, bottom }, 'qaTripleQty');
    return;
  }
  if (quickAddMode === 'dual') {
    const left = buildSideConfig('qaL');
    const right = buildSideConfig('qaR');
    if (!left || !right) { alert('Please fill all required fields for both sides'); return; }
    addMultiBinLabel({ cat:'dual', left, right }, 'qaDualQty');
    return;
  }

  const size = document.getElementById('qaSize').value;
  const len = document.getElementById('qaLength').value;
  const head = document.getElementById('qaHead').value;
  const drive = document.getElementById('qaDrive').value;
  const mat = document.getElementById('qaMat').value;
  const qty = parseInt(document.getElementById('qaQty').value) || 1;

  if (!size || !mat) { alert('Please select at least Size and Material'); return; }

  // If no length/head/drive, treat as hardware or prompt
  if (!len && !head && !drive) {
    // Add both nut and washer
    ['nut','washer'].forEach(cat => {
      const cfg = {cat, size, material:mat};
      const key = getLabelKey(cfg);
      selectedLabels.set(key, {cfg, qty});
    });
  } else if (len && head && drive) {
    const cfg = {cat:'screw', size, length:parseInt(len), head, drive, material:mat};
    const key = getLabelKey(cfg);
    if (!allLabels.some(l => getLabelKey(l) === key)) {
      allLabels.push(cfg);
      // Persist custom label to localStorage
      const custom = JSON.parse(localStorage.getItem('customLabels') || '[]');
      if (!custom.some(l => getLabelKey(l) === key)) {
        custom.push(cfg);
        localStorage.setItem('customLabels', JSON.stringify(custom));
      }
    }
    // Ensure custom length is in the filter
    if (!filters.len.has(cfg.length)) filters.len.add(cfg.length);
    selectedLabels.set(key, {cfg, qty});
  } else {
    alert('For screws, please select Length, Head, and Drive.'); return;
  }

  applyFilters();
  updateSelectionUI();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function init() {
  // Build length filter chips
  const lenContainer = document.getElementById('lenFilter');
  ALL_LENGTHS.forEach(l => {
    const chip = document.createElement('div');
    chip.className = 'chip length-chip active';
    chip.dataset.val = l;
    chip.textContent = l;
    chip.onclick = () => toggleFilter('len', l, chip);
    lenContainer.appendChild(chip);
  });

  buildAllLabels();

  // Load custom labels from localStorage
  const customLabels = JSON.parse(localStorage.getItem('customLabels') || '[]');
  for (const cfg of customLabels) {
    const key = getLabelKey(cfg);
    if (!allLabels.some(l => getLabelKey(l) === key)) {
      allLabels.push(cfg);
    }
    // Ensure custom lengths are included in the length filter
    if (cfg.cat === 'dual') {
      if (cfg.left.cat === 'screw' && !filters.len.has(cfg.left.length)) filters.len.add(cfg.left.length);
      if (cfg.right.cat === 'screw' && !filters.len.has(cfg.right.length)) filters.len.add(cfg.right.length);
    } else if (cfg.cat === 'triple') {
      for (const sub of [cfg.topLeft, cfg.topRight, cfg.bottom]) {
        if (sub.cat === 'screw' && !filters.len.has(sub.length)) filters.len.add(sub.length);
      }
    } else if (cfg.cat === 'quad') {
      for (const sub of [cfg.topLeft, cfg.topRight, cfg.bottomLeft, cfg.bottomRight]) {
        if (sub.cat === 'screw' && !filters.len.has(sub.length)) filters.len.add(sub.length);
      }
    } else if (cfg.cat === 'screw' && !filters.len.has(cfg.length)) {
      filters.len.add(cfg.length);
    }
  }

  initQuickAdd();

  // Start with minimal filter to keep initial load fast
  // Only show M4 by default
  filters.size = new Set(['M4']);
  document.querySelectorAll('#sizeFilter .chip').forEach(c => {
    c.classList.toggle('active', c.dataset.val === 'M4');
  });

  applyFilters();
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
